exfunc2(2,3)
exfunc2 <- function(a,b) {
y = abs(exfunc1(a,b))
return(y)
}
exfunc2(3,2)
exfunc2(2,3)
aggregate(Sales ~ Location, Fruits, sum, subset(Fruits, Date <= "2015-01-01"))
aggregate(Sales ~ Location, Fruits, sum, list(subset(Fruits, Date <= "2015-01-01")))
aggregate(Sales ~ Location, Fruits, sum, list(subset(Fruits, Date == "2015-01-01")))
aggregate(Sales ~ Location, Fruits, sum, subset(Fruits, Date == "2015-01-01"))
aggregate(Sales ~ Location, Fruits, sum, list(Fruits$Date <= '2018-01-01'))
aggregate(Sales ~ Location, Fruits, sum, list(Fruits$Date == '2018-01-01'))
aggregate(Sales ~ Location, Fruits, sum, list(Fruits$Date == as.character('2018-01-01')))
class(Fruits$Date)
aggregate(Sales ~ Location, Fruits, sum, list(Fruits$Date == as.Date('2018-01-01')))
Fruits$Date
Fruits$Date <- seq(as.Date("2010-01-01"),as.Date("2018-01-01"),by='year'); Fruits$Date
class(Fruits$Date)
aggregate(Sales ~ Location, Fruits, sum, list(Fruits$Date == as.Date('2018-01-01')))
Fruits$Date <= '2015-01-01'
which(Fruits$Date <= '2015-01-01')
which(Fruits$Date <= '2015-01-01' & >= '2013-01-01')
which(Fruits$Date == seq('2013-01-01','2017-01-01'))
which(Fruits$Date == seq(as.Date('2013-01-01'),as.Date('2017-01-01')),by='year')
which(Fruits$Date == seq(as.Date('2013-01-01'),as.Date('2017-01-01'),by='year'))
seq(as.Date('2013-01-01'),as.Date('2017-01-01'),by='year')
Fruits$Date
which(Fruits$Date == c(seq(as.Date('2013-01-01'),as.Date('2017-01-01'),by='year')))
which(Fruits$Date <= '2016-01-01' & Fruits$Date >= '2013-01-01')
which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')
Fruits$Date[,which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
Fruits$Date[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01'),]
Fruits$Date[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
Fruits2 <- Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
aggregate(Sales ~ Location, Fruits2, sum)
class(Fruits$Date)
setwd("D:/limworkspace/R_lecture/Part3")
getwd()
format(Sys.Date(), '%a')
format(Sys.Date(), '%b')
format(Sys.Date(), '%B')
format(Sys.Date(), '%d')
format(Sys.Date(), '%m')
format(Sys.Date(), '%y')
format(Sys.Date(), '%Y')
format(Sys.Date(), '%b',lang='en')                           # 한 자리 숫자의 ㄴ
format(Sys.Date(), '%B',lang='en')
format(Sys.Date(), '%b')                           # 한 자리 숫자의 ㄴ
format(Sys.Date(), '%B')
format(Sys.Date(), '%d')
format(Sys.Date(), '%m')
as.Date(Sys.Date()) - as.Date("2019-06-15")      # 날짜차이를 알고 싶을 때 단, 반드시 날짜형이어야함
as.Date("2019-05-30")+5                            # 해당 날짜에
seq(as.data(Sys.Date(),as.Date('2019-06-15')),by=1)
seq(as.Data(Sys.Date(),as.Date('2019-06-15')),by=1)
seq(as.Date(Sys.Date(),as.Date('2019-06-15')),by=1)
seq(as.Date(Sys.Date()),as.Date('2019-06-15'),by=1)
length(seq(as.Date(Sys.Date()),as.Date('2019-06-15'),by=1))
as.Date(Sys.Date()) - as.Date("2019-06-15")        # 날짜차이를 알고 싶을 때 단, 반드시 날짜형이어야함
seq(as.Date(Sys.Date()),as.Date('2019-06-15'),by=1)
seq(as.Date(Sys.Date()),as.Date('2020-06-15'),by='month')# 기간 날짜 생성, 1일 단위
seq(as.Date(Sys.Date()),as.Date('2019-06-15'),by='year')       # 기간 날짜 생성, 1일 단위
seq(as.Date(Sys.Date()),as.Date('2030-06-15'),by='year')       # 기간 날짜 생성, 1일 단위
seq(as.Date(Sys.Date()),as.Date('2019-06-15'),by=1)
seq(as.Date(Sys.Date()),as.Date('2030-06-15'),by='year')       # 기간 날짜 생성, 1일 단위
seq(as.Date(Sys.Date()),as.Date('2020-06-15'),by='quater')       # 기간 날짜 생성, 1일 단위
seq(as.Date(Sys.Date()),as.Date('2020-06-15'),by='quarter')       # 기간 날짜 생성, 1일 단위
date <- Sys.Date(); print(date)  # 현재 날짜만 출력 2019-05-30"
date <- now(); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
date <- Now(); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
today()
date <- Now(Sys.Date()); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
install.packages("lubridate")    # 패키지 설치
library(lubridate)               # 패키지 적용
date <- Now(); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
date <- now(); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
year(date)
month(date,label=T)
day(date)
year(date)
month(date,label=T)
month(date,label=T)
month(date,label=F)
wday(date,label = F)             # 요일을 숫자로 출력
wday(date,label = T)             # 요일을 한글로 출력
month(date,label=T)
month(date,label=T)              # date 변수의 월
day(date)
date <- date - days(2); date
month(date) <- 2; date           # 날짜를 2월로 설정하기
month(date) <- 2; date           # 날짜를 2월로 설정하기
date <- date - days(2); date
date
date <- Sys.Date(); print(date)  # 현재 날짜만 출력 2019-05-30"
date <- date - days(2); date
date2 <- now(); print(date2)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
date <- date - days(2); date
month(date) <- 2; date           # 날짜를 2월로 설정하기
month(date) <- 2
date
date
date <- now(); print(date)
date+months(3)
date2 <- now(); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
date2 <- now(); print(date2)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
month(date2) <- 2; date2           # 날짜를 2월로 설정하기
month(date) <- 2; date           # 날짜를 2월로 설정하기
month(date) <- 2; date           # 날짜를 2월로 설정하기
month(date2) <- 2; date2           # 날짜를 2월로 설정하기
date <- Sys.Date(); print(date)  # 현재 날짜만 출력 2019-05-30"
date2 <- now(); print(date2)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
month(date) <- 2; date           # 날짜를 2월로 설정하기
month(date2) <- 2; date2           # 날짜를 2월로 설정하기
date2 <- date - days(2); date2
date2
date <- now(); print(date)       # 현재 날짜와 시간까지 출력  "2019-05-30 09:50:01 KST"
date
days(2)
date2 <- date - days(2); date2
date <- now(); print(date)
# 날짜의 형식 지정하기
ymd("2017-03-01")
mdy("March 1st,2017")
# 날짜의 형식 지정하기
ymd("2017-03-01")
mdy("March 2st,2017")
dmy("1-Mar-2017")
ymd_hms(Sys.Date() 21:11:32))
ymd_hms("2019-01-01 21:11:32"))
ymd_hms("2019-01-01 21:11:32")
library(lubridate)               # 패키지 적용
ymd_hms("2019-01-01 21:11:32")
?ymd
install.packages("lubridate")    # 패키지 설치
install.packages("lubridate")
library(lubridate)               # 패키지 적용
ymd_hms("2019-06-02 04:30:14",tz='KTC')
Sys.Date()
now()
ymd_hms("2019-06-02 04:30:14",tz='KST')
ymd_hms("2019-06-02 04:30:14", tz="KST")
ymd_hms("2019-06-02 04:30:14", tz=KST)
ymd_hms("2019-06-02 04:30:14", tz=UTC)
ymd_hms("2019-06-02 04:30:14", tz="UTC")
ymd_hms("2019-01-01 21:11:32")
install.packages("tidyverse")
install.packages("nycflights13")
library(tidyverse)
library(nycflights13)
flights
install.packages("dplyr")
install.packages("dplyr")
2012:2014
date.dfm <- data.frame(year = c(2012:2014),
month = c(4:6),
day = c(28:30)); date.dfm
date.dfm$date <- make_date(year = date.dfm$year,
month = date.dfm$month,
day = date.dfm$day); date.dfm
date.dfm$date <- make_date(year = date.dfm$year,
month = date.dfm$month,
day = date.dfm$day); date.dfm; class(date.dfm$date)
date.dfm[,-"date"]; date.dfm
date.dfm[,-c("date")]; date.dfm
subset(date.dfm, select = -"date")
subset(date.dfm, select = "date")
subset(date.dfm, select != "date")
which(subset(date.dfm, select = "date"))
subset(date.dfm, select = "date")
subset(date.dfm, select = -c("date"))
subset(date.dfm, select = -c(date))
iris
str(iris)
subset(iris, select = -c(Petal.Width))
str(subset(iris, select = -c(Petal.Width)))
rm(list = ls())
no <- c(1:4)
name <- c('apple','peach','banana','grape')
price <- c(500,200,100,50)
qty <- c(5,2,4,7)
sales <- data.frame(NO = no,
NAME = name,
PRICE = price,
QTY = qty); sales
sales[,-c(1,4)]                                          # data.frame의 모든 행과 1, 4열의 값을 출력한다.
subset(sales, select = year)
subset(sales, select = name)
subset(sales, select = 'name')
sales
subset(sales, select = NAME)
subset(sales, select = -NAME)
subset(sales, select = -qty)
subset(sales, select = -qty)
sales
subset(sales, select = -qty)
subset(sales, select = -NAME)                           # 제외도 가능
subset(sales, select = -qty)
sales
subset(sales, select = -qty)
subset(sales, select = -QTY)
subset(sales, select = NAME)                            # select 옵션으로 원하는 열만 조회 가능
sales
sales[which(sales$PRICE >= 150),]
no <- c(1:5)
name <- c("서진수",'주시현','최경우','이동근','윤정웅')
address <- c('서울','대전','포항','경주','경기')
tel <- c(111,222,333,444,555)
hobby <- c('독서','미술','놀고먹기','먹고놀기','노는애감시하기')
member <- data.frame(NO=no,
NAME=name,
ADDRESS=address,
TEL=tel,
HOBBY=hobby); member
member2 <- subset(member, select=c(NO,NAME,TEL)); member2           # member 데이터에서 NO, NAME, TEL 변수만 추출하기
member3 <- subset(member, select= -TEL); member3                    # member 데이터에서 TEL 변수만 빼고 추출하기
colnames(member3) <- c('번호','이름','주소','X_DD..취미'); member3
colnames(member3)[4] <- "취미"                                      # 데이터 프레임 임의의 변수명을 선택해 바꾸기
colnames(member3)[1:3]
colnames(member3) <- c('번호오','이르음','주우소','X_DD..취미'); member3
colnames(member3)[4] <- "취미"                                      # 데이터 프레임 임의의 변수명을 선택해 바꾸기
colnames(member3)[4] <- "취미"; str(member3)                        # 데이터 프레임 임의의 변수명을 선택해 바꾸기
colnames(member3)[1:3] <- c("번호","이름",'주소')
colnames(member3)[1:3] <- c("번호","이름",'주소'); str(member3)
no <- c(1:3)
name <- c('apple','banana','peach')
price <- c(100,200,300)
df1 <- data.frame(NO = no,
NAME = name,
PRICE = price); df1
no <- c(10,20,30)
name <- c('train','car','airplane')
price <- c(1000,2000,3000)
df2 <- data.frame(NO = no,
NAME = name,
PRICE = price); df2
df3 <- cbind(df1,df2); df3
df3$NAME                                                # 앞에있는 과일만
df3[,5]                                                 # 뒤에있는 탈 것들
df4 <- rbind(df1,df2); df4
name <- c('apple','banana','cherry')
price <- c(300,200,100)
df5 <- data.frame(name = name,
price = price); df5
name <- c('apple','cherry','berry')
qty <- c(10,20,30)
df6 <- data.frame(name = name,
qty = qty); df6
new <- data.frame(name="mango",price=400)
df5 <- rbind(df5, new); df5
df5 <- rbind(df5, data.frame(name="mango",price=400)); df5
df5 <- cbind(df5, data.frame(quantity=c(10,20,30,40,50))); df5
# 1. Inner_join : 특정기준에서 A와 B 둘다 포함된 항목만 병합
merge(df5, df6)
# 2. Outer_join : A와 B전체를 병합
merge(df5, df6, all=T)
# 3. Left_join : A를 기준으로 B를 병합
merge(df5, df6, all.x = T)
merge(df5, df6, all.x = T, by = price)
merge(df5, df6, all.x = T, by = 'price')
merge(df5, df6, by = 'price',all.x = T)
merge(df5, df6, by='price',all.x = T)
df5 <- rbind(df5, data.frame(name="mango",price=400)); df5
df5 <- cbind(df5, data.frame(quantity=c(10,20,30,40,50))); df5
df5 <- data.frame(name = name,
price = price); df5
df6 <- data.frame(name = name,
qty = qty); df6
merge(df5, df6, by='name',all.x = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df5, df6, by=,'name',all.y = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df5, df6, all.y = T)
merge(df5, df6, by=,'name',all.y = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df6, df5, all.y = T)
merge(df6, df5, by=,'name',all.y = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df6, df5, all.y = T)
df6
# 4. Right_join : B를 기준으로 A를 병합
merge(df6, df5, all.y = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df5, df6, all.y = T)
merge(df5, df6, by=,'name',all.y = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df5, df6, all.y = T)
merge(df5, df6, by=,'name',all.y = T)
merge(df5, df6, by=,'price',all.y = T)
merge(df5, df6, by=,'name',all.y = T)
# 3. Left_join : A를 기준으로 B를 병합
merge(df5, df6, all.x = T)
merge(df5, df6, by='name',all.x = T)
# 4. Right_join : B를 기준으로 A를 병합
merge(df5, df6, all.y = T)
merge(df5, df6, by=,'name',all.y = T)
# 2. Outer_join : A와 B전체를 병합
merge(df5, df6, all=T)
# 1. Inner_join : 특정기준에서 A와 B 둘다 포함된 항목만 병합
merge(df5, df6)
df6 <- data.frame(name = name,
qty = qty); df6
df5 <- data.frame(name = name,
price = price); df5
df5 <- data.frame(name = name,
price = price); df5
name <- c('apple','cherry','berry')
qty <- c(10,20,30)
df6 <- data.frame(name = name,
qty = qty); df6
df5 <- data.frame(name = name,
price = price); df5
name <- c('apple','cherry','berry')
qty <- c(10,20,30)
df6 <- data.frame(name = name,
qty = qty); df6
name <- c('apple','banana','cherry')
price <- c(300,200,100)
df5 <- data.frame(name = name,
price = price); df5
# 4. Right_join : B를 기준으로 A를 병합
merge(df5, df6, all.y = T)
merge(df5, df6, by=,'name',all.y = T)
# 3. Left_join : A를 기준으로 B를 병합
merge(df5, df6, all.x = T)
merge(df5, df6, by='name',all.x = T)
merge_df1<-data.frame(name = c('Yoon', 'Seo', 'Park', 'Lee', 'Kim', 'Kang'),
age = c(30, 31, 22, 24, 28, 25))
merge_df2<-data.frame(name = c('Park', 'Lee', 'Kim', 'Kang', 'Ahn', 'Go'),
gender=c('f', 'f', 'm', 'm', 'f', 'm'),
city = c('Seoul', 'Incheon', 'Seoul',
'Busan', 'Gwangju', 'Deagu'))
merge_df1<-data.frame(name = c('Yoon', 'Seo', 'Park', 'Lee', 'Kim', 'Kang'),
age = c(30, 31, 22, 24, 28, 25)); merge_df1
merge_df2<-data.frame(name = c('Park', 'Lee', 'Kim', 'Kang', 'Ahn', 'Go'),
gender=c('f', 'f', 'm', 'm', 'f', 'm'),
city = c('Seoul', 'Incheon', 'Seoul',
'Busan', 'Gwangju', 'Deagu')); merge_df2
merge(merge_df1,merge_df1,by='name',all=T)
merge(merge_df1,merge_df2,by='name',all=T)
# 1. Inner_join : 특정기준에서 A와 B 둘다 포함된 항목만 병합
merge(df5, df6, all=F)
# test 1 : Inner_join
merge(merge_df1,merge_df2,by='name',all=F)
# test 2 : Outer_join
merge(merge_df1,merge_df2,by='name',all=T)
# test 2 : Outer_join
merge(merge_df1,merge_df2,all=T)
# test 3 : Left_join
merge(merge_df1,merge_df2,by='name',all.x=T)
# test 4 : Right_join
merge(merge_df1,merge_df2,by='name',all.y=T)
merge_df2
# test 4 : Right_join
merge(merge_df1,merge_df2,by='name',all.y=T)
# test 3 : Left_join
merge(merge_df1,merge_df2,by='name',all.x=T) # df1의 name 기준으로 공통으로 들어 있는 이름에 대해서만 조인
# test 4 : Right_join
merge(merge_df1,merge_df2,by='name',all.y=T) # df2의 name 기준으로 공통으로 들어 있는 이름에 대해서만 조인
nchar("limwonki")
paste("lim","wonki",sep="-")
past2("lim","wonki")
paste2("lim","wonki")
paste0("lim","wonki")
paste("lim","wonki",sep="-", collapse=",and")     # 문자열 붙이기
# 4.2.1 다양한 문자열 다루기 함수------------------------------------------------------------
vec1 <- "lim"
vec2 <- "wonki"
nchar(vec1)                                 # 문자열 길이 추출
paste(vec1,"he is student",sep="-", collapse=",and")     # 문자열 붙이기
paste(vec1,"he is student",collapse=",and")     # 문자열 붙이기
paste(vec1,"he is student",sep="-")     # 문자열 붙이기
paste(vec1,"he is student",collapse=",and")     # 문자열 붙이기
vec3 <- "lim ,and kim"
paste(vec3,"he is student",collapse=",and")     # 문자열 붙이기
# 4.2.1 다양한 문자열 다루기 함수------------------------------------------------------------
vec1 <- "lim"
vec2 <- "wonki"
nchar(vec1)                                 # 문자열 길이 추출
paste(vec1,"he is student",sep="-")     # 문자열 붙이기, sep(seprate) 옵션으로 구분 가능
paste(vec1,"he is student",sep=",")     # 문자열 붙이기, sep(seprate) 옵션으로 구분 가능
paste(vec1,"he is student",sep=", ")     # 문자열 붙이기, sep(seprate) 옵션으로 구분 가능
paste(c('첫','두','세'),rep('번째',3),collapse=", and")     # 문자열 붙이기
paste(c('첫','두','세'),rep('번째',3),collapse=", and ")     # 문자열 붙이기
paste(c('첫','두','세'),rep('번째',3),collapse=", ")     # 문자열 붙이기
paste0(vec1,vec2,"fighting")                             # 공백없이 문자열 붙이기
paste0(vec1,vec2)                             # 공백없이 문자열 붙이기
paste(c('첫','두','세'),rep('번째',3),collapse=", ")     # 문자열 붙이기
paste(vec1,"he is student",sep=", ")                     # 문자열 붙이기, sep(seprate) 옵션으로 구분 가능
paste(c('첫','두','세'),rep('번째',3),collapse=", ")     # 결과값이 2개 이상일 때 collapse 옵션으로 연결
paste0(vec1,vec2)                             # 공백없이 문자열 붙이기
# paste 함수 참고 :https://m.blog.naver.com/coder1252/220985161855
substr("limwonki",1,3)
substr("limwonki",3,1)                                   # 첫번째 ~ 세번째 문자열 추출
substr("limwonki",-3,-1)                                   # 첫번째 ~ 세번째 문자열 추출
strsplit("lim-wonki",'-')
gsub_data <- data.frame(name = c('lim wk',"lim kk", "lim qq"))
gsub("lim","kim",gsub_data); gsub_data
gsub(lim,kim,gsub_data); gsub_data
gsub_data <- data.frame(name = c('lim wk',"lim kk", "lim qq"))
gsub("lim","kim",gsub_data); gsub_data
gsub_data <- data.frame(name = c('limwk',"limkk", "limqq"))
gsub("lim","kim",gsub_data); gsub_data
gsub_data2 <- gsub("lim","kim",gsub_data); gsub_data2
gsub_data2
gsub_data <-c('limwk',"limkk", "limqq"))
gsub_data <-c('limwk',"limkk", "limqq")
gsub_data2 <- gsub("lim","kim",gsub_data); gsub_data2
gsub_data <-c('limwk',"limkk", "limqq")                  # 찾아바꾸기 sub (단일) gsub(전체) gsub(pattern, replacement, data)
gsub_data2 <- gsub("lim","kim",gsub_data); gsub_data2    # 단 data frame 형태에서는 적용이 안됨, vector 형태에만 적용되는 듯(?)
gsub
data <-c('limwk',"limkk", "limqq")                  # 찾아바꾸기 sub (단일) gsub(전체) gsub(pattern, replacement, data)
gsub_data <- gsub("lim","kim",gsub_data); gsub_data    # 단 data frame 형태에서는 적용이 안됨, vector 형태에만 적용되는 듯(?)
grep(data,"lim")
grep("lim",data)
grep("qq",data)
grep("qq",data)                                          # grep(pattern, data) data내의 패턴의 위치를 알려줌
test.data
install.packages("plyr")
library(plyr)
# ex)
airquality
result <- ddply(subset(airquality, ozone >= 30), .(month, day), summarise, mean_temp = mean(temp)); result
str(airquality)
result <- ddply(subset(airquality, ozone >= 30), summarise, mean_temp = mean(temp)); result
ddply(airquality,"year",summarise,mena=mean(temp))
ddply(airquality,"Month",summarise,mena=mean(temp))
ddply(airquality,"Month",summarise,mena=mean(Temp))
ddply(airquality,"Month",summarise,mean=mean(Temp))
ddply(airquality,"Month",transform,mean=mean(Temp))
ddply(subset(airquality,Ozone >= 30), summarise, mean = mean(Temp))
ddply(subset(airquality,Ozone >= 30),"Month",summarise, mean = mean(Temp))
# 8.1.2 aggregate (함계, 총계) 함수 ---------------------------------------------------------------------------------------
install.packages("googleVis")
library(googleVis)
# aggregate( 계산이 될 열 ~ 기준이 될 열 , 데이터, 함수 )
str(Fruits)
aggregate(Sales ~ Year, Fruits, sum)           # Fruits 데이터의 연도[기준]별 총[함수] 판매량[계산]
aggregate(Profit ~ Year, Fruits, mean)
aggregate(Sales ~ Fruit+Location, Fruits, max) # 추가조건은 +를 사용
Fruits2 <- Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
aggregate(Sales ~ Location, Fruits2, sum)
class(Fruits$Date)
aggregate(Sales ~ Location, Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')], sum)
aggregate(Sales ~ Location, Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')], sum)
# aggregate( 계산이 될 열 ~ 기준이 될 열 , 데이터, 함수 )
str(Fruits)
Fruits$Date <- seq(as.Date("2010-01-01"),as.Date("2018-01-01"),by='year'); Fruits$Date
aggregate(Sales ~ Location, Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')], sum)
Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
Fruits2
Fruits2 <- Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')]
Fruits2
which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01')
Fruits2 <- Fruits[which(Fruits$Date >= '2013-01-01' & Fruits$Date <= '2016-01-01'),]
Fruits2
aggregate(Sales ~ Location, Fruits2, sum)
class(Fruits$Date)
Fruits
Fruits2 <- Fruits[which(Fruits$Date >= '2011-01-01' & Fruits$Date <= '2014-01-01'),]
aggregate(Sales ~ Location, Fruits2, sum)
class(Fruits$Date)
aggregate(Sales ~ Location, subset(Fruits$Date >= '2011-01-01' & Fruits$Date <= '2014-01-01'),sum)
?aggregate
subset(Fruits$Date >= '2011-01-01' & Fruits$Date <= '2014-01-01')
subset(Fruits$Date >= '2011-01-01')
aggregate(Sales ~ Location, subset(Fruits,Date >= '2011-01-01'),sum)
aggregate(Sales ~ Location, subset(Fruits, Date >= '2011-01-01' & Date <= '2014-01-01'),sum)
aggregate(Sales ~ Location, Fruits2, sum)
aggregate(Sales ~ Location, subset(Fruits, Date >= '2011-01-01' & Date <= '2014-01-01'),sum)
attach(Fruits)                                 # tapply를 사용하기 전 attach 명령이 반드시 필요함
attach(Fruits)
tapply(Sales,Date,sum)
tapply(Sales,subset(Date>='2011-01-01'),sum)
?tapply
detach(Fruits)
Fruits
aggregate(Sales ~ Location+Fruts, Fruits, var+sd)
aggregate(Sales ~ Location+Fruits, Fruits, var+sd)
aggregate(Sales ~ Location+Fruits, Fruits, list(var+sd))
aggregate(Sales ~ Location+Fruit, Fruits, list(var+sd))
aggregate(Sales ~ Location+Fruit, Fruits, var,sd)
aggregate(Sales ~ Location+Fruit, Fruits, var)
aggregate(Sales ~ Location+Fruit, Fruits, sum)
Fruits3 <- Fruits3[4:5,3] <- c("West"); Fruits3
Fruits3 <- Fruits3[4:5,3] = c("West"); Fruits3
Fruits3 <- Fruits3[4:5,3] = "West"; Fruits3
Fruits3 <- Fruits3[4:5,3] = "West"; Fruits3
Fruits3[4:5,3]
Fruits[4:5,3]
Fruits
Fruits[4:5,3]
Fruits[4:5,]
Fruits3 <- Fruits[4:5,3] = "West"; Fruits3
Fruits3 <- Fruits[4:5,3] <- "West"; Fruits3
Fruits3
Fruits[4:5,3] <- "West"
aggregate(Sales ~ Location+Fruit, Fruits, sum)
# aggregate( 계산이 될 열 ~ 기준이 될 열 , 데이터, 함수 )
str(Fruits)
Fruits
aggregate(Sales ~ Location+Fruit, Fruits, sum)
Fruits
Fruits[3,3] <-"East"
aggregate(Sales ~ Location+Fruit, Fruits, sum)
attach(Fruits)
tapply(Sales,subset(Date>='2011-01-01'& Date <= '2014-01-01'),sum)
tapply(Sales,subset(Date>='2011-01-01'& Date <= '2014-01-01'),sum)
tapply(Sales,subset(Date>='2011-01-01'),sum)
detach(Fruits)
