#--------------------------------------------------------------#
#               코딩에서 가장 중요한 것 두 가지                #
#                                                              #
#                        1. Indentation                        #
#                                                              # 
#                        2. Comment                            #
#--------------------------------------------------------------#


#--------------------------------------------------------------#
#------------- section 6 : R Vector 형태 다루기 ---------------#
#--------------------------------------------------------------#


# 6.1 Vector : 단일값(스칼라)들이 한 군데 모여 있는 자료구조 -----------------------------------

c(1:5)
c(1,2,3,4,"5")                  # 숫자가 문자로 자동변환
                                # Vector는 한가지 타입의 데이터 형태만 가질 수 있다.

# vector 생성 연산자 :
# vector 생성 함수 : c(), seq(), rep

c(1:5)
c(1,2,3,4,"5")                  # 숫자가 문자로 자동변환
seq(1,5,2)                      # 위치 argument
seq(by=2, from=2, to=6)         # 키워드 argument
seq(-3,3, length.out = 61)      # length.out : from ~ to 사이에 생성할 vector의 개수 지정  
seq(-3,3, 0.1)                  # 간격 설정
rep(1:3,each=2)                 # 각각 반복
rep(1:3,time=2)                 # 전체 반복 

# 어떤 컴퓨터 언어에서든지 자료에 access 할 수 있다고 할 때, CRUD를 알고 있어야 한다  
# C : creat 
# R : retrieve 
# U : update 
# D : delete 


# 6.1.1 벡터 내의 원소에 접근하기 - 슬리이싱(Slicing)과 필터링(Filtering) ----------------------

vec1 <- c(1:5); vec1
vec1[3]                         # 세 번째 요소만 보여준다. R에서는 1에서 시작, 타 언어는 0
vec1[-3]                        # 세 번째 요소만 빼고 보여준다. 
vec1[2:4]                       # 2-4번쨰 요소를 보여준다.
length(vec1)                    # length : 벡터의 원소개수 파악
vec1[1:(length(vec1)-2)]
vec1[1:length(vec1)]
vec1[-(1:3)]                    # 1-3번째 요소를 뺴고 보여준다. 
vec1[2] <- 6; vec1              # vec1의 두 번째 값을 6으로 변경 
vec1 <- c(vec1,7); vec1         # 벡터에 새로운 내용을 추가할 수 있다. 
vec1[7] <- 8; vec1
vec1[9] <- 9; vec1              # 요소사이에 빈 공간은 NA로 처리된다.

append(vec1,10,after=3)         # vec1의 3 번쨰 값 뒤에 10을 넣고자할 때 사용할 수 있다.
append(vec1,(-7:-1),after=7)    # 다양한 값 설정이 가능하다. 
append(vec1,100,after=0)        # 0은 가장 앞자리를 의미한다. 

ex <- c(1,3,7,NA,12)
ex < 10
ex[ex %% 2 == 0]                # ex에서 2로 나누어 나머지가 0인 수, 즉 짝수를 추출 
ex[is.na(ex)]                   # ex에서 값이 NA인 값 추출 
ex[ex %% 2 == 0 & is.na(ex)]    # ex에서 짝수이며, NA가 아닌 값 추출 

# 6.1.2 벡터로 연산하기 ------------------------------------------------------------------------

c(1,2,3)+c(4,5,6)
c(1,2,3)+1

var1 <- c(1,2,3)
var2 <- c(4,5,6)
var1 + var2
var3 <- c('3','4',5)
var1 + var3                     # 다른 형태의 변수는 연산을 할 수 없다.
union(var1, var3)               # 데이터의 형태가 다를 경우 union을 사용해야 한다. 
                                # union = 합집합(var1 ∪ var2)

var4 <- c(1,2,3,4,5)
var1; var4                      #   1,2,3,(1),(2)  객체의 길이가 서로다른 경우 순환 원리가 적용됨
var1+var4                       # + 1,2,3, 4 , 5
                                # = 2,4,6, 5 , 7

var2 <- c(3,4,5)
var1 - var2

intersect(var1,var2)            # intersect = 교집합 (var1 ∩ var2)                               
setdiff(var1,var2)              # setdiff = 차집합 (var1 - var2)
setdiff(var2,var1)


# 6.1.3 벡터의 각 컬럼에 이름 지정하기 --------------------------------------------------------

fruits <- c(10,20,30); fruits
names(fruits) <- c('apple','banana','peach'); fruits  # names(변수명)는 벡터의 이름 설정 함수다.


# 6.1.4 벡터에 연속적인 데이터 할당하기 -------------------------------------------------------

var5 <- seq(1,6); var5
var6 <- seq(2,-2); var6
even <- seq(2,10,by=2); even       # seq(from, to, by), by는 증가분 즉, 간격을 의미한다. 
odd <- seq(1,10,2); odd
var8 <- rep(1:3, times=2); var8    # rep(x, times) x값을 전체 반복 
var9 <- rep(1:3, each=2); var9     # rep(x, each) x값을 각각 반복 

# 6.1.5 벡터의 길이 찾기 ----------------------------------------------------------------------

length(var1)
nrow(var1)                         # nrow는 number of row로 벡터에서는 사용이 불가하고 배열에서 사용 


# 6.1.6 벡터에 특정 문자의 포함 여부 찾기 -----------------------------------------------------

5 %in% even                        # even 변수에 5의 포함여부 묻기 
4 %in% even


# 6.1 연습문제 p 323 --------------------------------------------------------------------------

# 1. seq() 함수를 사용해 date4 변수에 2015-01-01 부터 2015-01-31까지 1씩 증가하는 날짜를 입력하는 방법은?

date4 <- seq(as.Date("2015-01-01"),as.Date("2015-01-31"),by=1); date4

# 2. vec1의 3번째 요소값을 뺀 vec1의 값을 출력하는 방법은?

vec1 <- c('사과','배','감','버섯','고구마'); vec1
vec1[-3]

# 3. vec1과 vec2의 합집합, 차집합, 교집합을 구하는 방법은? 

vec1 <- c('봄','여름','가을','겨울')
vec2 <- c('봄','여름','늦여름','초가을')

union(vec1,vec2)
setdiff(vec1,vec2)
intersect(vec1,vec2)

rm(list=ls())


# *** Factor : 질적 자료를 저장하는 자료구조 ------------------------------------------------------------------------------
# factor(x = character(), levels, labels = levels, ordered=FALSE)

# x : factor로 만들 데이터
# levels : 주어진 데이터 중 factor의 각 값(수준)으로 할 값을 벡터 형태로 지정(여기서 빠진 값은 NA로 처리)
# labels : 실제 값 외에 사용할 각 수준의 이름, 예를 들어 데이터에서 1이 남자를 가리킬 경우 labels를 통해 "남" 혹은 "M"으로 변경
# ordered : 순위형 자료 여부(T/F)로, levels에 입력한 순서를 가짐. 순서형 자료에 사용 

x <- 1:5
factor(x, levels = c(1:4))
factor(x, levels = c(1:4), labels = c('a','b','c','d')) # 레이블 변경 
factor(x, levels = c(1:4), ordered = T)                 # 순서 자동 지정 (ordered = T 옵션 : 순서형 자료) 
factor(x, levels = c(4,2,3,1,5))                        # 순서 직접 지정 

weekends <- c("일","월","화","수","목","금","토")
factor(weekends, levels = c("월","화","수","목","금","토","일")) # 순서 변경 

factor(1:7, levels = 1:7, labels = c("일","월","화","수","목","금","토"), ordered = T) 

